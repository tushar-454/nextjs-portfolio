export type TArticle = {
  title: string;
  slug: string;
  category: 'Security';
  content: string;
};

export const articles: TArticle[] = [
  {
    title:
      'CSRF Attacks: কিভাবে হ্যাকাররা ইউজারদের অ্যাকাউন্ট হাইজ্যাক করতে পারে!',
    slug: 'csrf-attacks',
    category: 'Security',
    content: `

### CSRF Attacks: কিভাবে হ্যাকাররা ইউজারদের অ্যাকাউন্ট হাইজ্যাক করতে পারে!

Cross-Site Request Forgery (CSRF) একটি ওয়েব সিকিউরিটি ভালনারেবিলিটি। এর মাধ্যমে অ্যাটাকার ইউজারদের না জানিয়েই তাদের কিছু অ্যাকশন পারফর্ম করতে বাধ্য করতে পারে। এটা মূলত একটা সাইটের উপর ইউজারের ব্রাউজারের যে ট্রাস্ট থাকে, সেটাকে কাজে লাগায়।

### CSRF কি?

CSRF অ্যাটাকগুলো ঘটে যখন কোনো ম্যালিশিয়াস ওয়েবসাইট, ইমেইল, ব্লগ, ইনস্ট্যান্ট মেসেজ বা প্রোগ্রাম ইউজারের ওয়েব ব্রাউজারকে দিয়ে কোনো ট্রাস্টেড সাইটে \`https://facebook.com\` অ্যাকশন পারফর্ম করায়, যেখানে ইউজার অথেনটিকেটেড। CSRF অ্যাটাকগুলো মূলত স্টেট-চেঞ্জিং রিকোয়েস্টগুলোকে টার্গেট করে, ডেটা চুরি করা এর উদ্দেশ্য নয়, কারণ অ্যাটাকার ফর্জড রিকোয়েস্টের রেসপন্স দেখতে পায় না।

### কেন CSRF গুরুত্বপূর্ণ

CSRF এর কারণে যা হতে পারে:

- অ্যাকাউন্ট কম্প্রোমাইজ
- অননুমোদিত ফান্ড ট্রান্সফার
- ডেটা পরিবর্তন
- ম্যালওয়্যার ছড়ানো

### CSRF কিভাবে কাজ করে

  - ** ইউজার লগ ইন:** ইউজার একটা ট্রাস্টেড ওয়েবসাইটে (যেমন \`bank.com\`) অথেনটিকেট করে। সাইটটি ইউজারের ব্রাউজারে একটা সেশন কুকি সেট করে।
- **অ্যাটাকারের সাইট:** যেকোনো ওয়েতে ইউজার অ্যাটাকারের কন্ট্রোল করা একটা ম্যালিশিয়াস ওয়েবসাইট (\`attacker.com\`) ভিজিট করে।
- **ফর্জড রিকোয়েস্ট:** অ্যাটাকারের সাইটে HTML কোড থাকে যা ট্রাস্টেড সাইটে একটা রিকোয়েস্ট ট্রিগার করে (যেমন \`bank.com/transfer?amount=1000&to=attacker\`)। এটা একটা ইমেজ ট্যাগ, ফর্ম বা জাভাস্ক্রিপ্টের মাধ্যমে করা হয়।
- **ব্রাউজার রিকোয়েস্ট পাঠায়:** ইউজারের ব্রাউজার অটোমেটিকভাবে \`bank.com\` এর সেশন কুকি যুক্ত করে রিকোয়েস্ট পাঠায় রিসোর্চ সার্ভার। যদি সার্ভারে CORS সেটআপ থাকে অথবা ব্রাউজার CORS ফিচার এর জন্য রিকোয়েস্ট সফল নাও হতে পারে তাই CORS বাইপাস এর জন্য অ্যাটাকারের অ্যাডিশনাল কনফিগারেশন করতে হতে পারে।
- **ব্যাংক রিকোয়েস্ট এক্সিকিউট করে:** \`https://bank.com\` রিকোয়েস্ট রিসিভ করে, কুকি ভ্যালিডেট করে এবং ট্রান্সফার প্রসেস করে, যেন ইউজার নিজেই এই রিকোয়েস্ট করেছে।

### কখন CSRF হতে পারে

CSRF তখনই সম্ভব যখন:

- সাইট শুধুমাত্র কুকিজের উপর নির্ভর করে অথেনটিকেশনের জন্য।
- কুকি তৈরি সময় অপশন গুলো প্রপার ব্যবহার না করা।
- সার্ভারে কোনো প্রোপার CORS কনফিগারেশন সেট না করা।
- সাইটে কোনো প্রোপার CSRF প্রোটেকশন না থাকা।
- ইউজার টার্গেট সাইটে কারেন্টলি অথেনটিকেটেড থাকা।

### CSRF অ্যাটাকের প্রকার

- **GET-based CSRF:** অ্যাটাকার ম্যালিশিয়াস প্যারামিটার দিয়ে একটা URL তৈরি করে। এটা প্রায়ই \`<img>\` ট্যাগ বা লিংকের মাধ্যমে ডেলিভার করা হয়।
- **POST-based CSRF:** অ্যাটাকার একটা হিডেন ফর্ম তৈরি করে যা অটোমেটিকভাবে টার্গেট সাইটে সাবমিট হয়। এর জন্য ইউজারকে ফর্ম থাকা একটা পেজ ভিজিট করতে হয়।

### রিয়েল-লাইফ উদাহরণ

- **ইমেইল অ্যাড্রেস পরিবর্তন:** অ্যাটাকার একটা ফোরামে ইউজারের ইমেইল অ্যাড্রেস পরিবর্তন করার জন্য একটা রিকোয়েস্ট ফর্জ করতে পারে, যা অ্যাকাউন্ট টেকওভারের দিকে নিয়ে যেতে পারে।
- **সোশ্যাল মিডিয়া অ্যাকশন:** অ্যাটাকার ইউজারকে না জানিয়েই একটা পেজে "লাইক" দিতে বা স্ট্যাটাস আপডেট করতে পারে।
- **ব্যাংকিং ট্রানজেকশন:** শুরুতে যে উদাহরণ দেওয়া হয়েছে, সেভাবে ফান্ড ট্রান্সফার করা।

### কোডিং উদাহরণ

ধরা যাক, একটা ব্যাংকের মানি ট্রান্সফার করার জন্য একটা URL আছে:

\`https://bank.example/transfer.do?acct=VICTIM-ACCOUNT&amount=100&for=EvilUser\`

অ্যাটাকার ভিকটিমের কাছে নিচের HTML কোডটি পাঠাতে পারে:

\`\`\`html
<img
  src="<https://bank.example/transfer.do?acct=VICTIM-ACCOUNT&amount=100&for=EvilUser>"
  width="0"
  height="0"
/>

\`\`\`

যদি ইউজার \`bank.example\` এ লগইন করা থাকে, তাহলে এই \`<img>\` ট্যাগটি \`EvilUser\` এর অ্যাকাউন্টে ১০০ ডলার ট্রান্সফার করে দেবে, যখন ভিকটিম HTML দেখবে (যেমন কোনো ফোরাম পোস্ট বা ইমেইলে)।

### সলিউশন ও প্রিভেনশন

- **CSRF টোকেন (Synchronizer Token Pattern):**
    - সার্ভার প্রত্যেক ইউজার সেশনের জন্য একটা ইউনিক, আনপ্রেডিক্টেবল টোকেন জেনারেট করে।
    - এই টোকেন সব ফর্মের মধ্যে একটা হিডেন ফিল্ড হিসেবে যোগ করা হয়।
    - যখন ফর্ম সাবমিট করা হয়, সার্ভার ভেরিফাই করে যে রিকোয়েস্টের টোকেনটা ইউজারের সেশনে স্টোর করা টোকেনের সাথে ম্যাচ করছে কিনা।

উদাহরণ (HTML):

\`\`\`html
<form
  action="/transfer"
  method="POST"
>
  <input
    type="hidden"
    name="csrf_token"
    value="UNIQUE_CSRF_TOKEN"
  />
  <input
    type="text"
    name="amount"
  />
  <button type="submit">Transfer</button>
</form>

\`\`\`

\- উদাহরণ (সার্ভার-সাইড ভেরিফিকেশন):

\`\`\`jsx
if (req.method === 'POST') {
  const csrfToken = req.body.csrf_token;
  if (csrfToken !== req.session.csrfToken) {
    return res.status(403).send('Forbidden');
  }
  // ... process the transfer
}

\`\`\`

- **ডাবল সাবমিট কুকি:**
    - সার্ভার একটা রেন্ডম বা এলোমেলো ভ্যালু তৈরি করে। এই ভ্যালুটা কুকিতে এবং ফর্মের একটা ফিল্ড হিসেবে সেট করে।
    - যখন ফর্ম সাবমিট করা হয়, তখন সার্ভার দেখে কুকির ভ্যালু আর ফর্মের ফিল্ডের ভ্যালু একই কিনা। যদি মিলে যায়, তার মানে রিকোয়েস্টটা সেইম সাইট থেকে এসেছে।
    - এটা সেইম-অরিজিন পলিসি ব্যবহার করে। এর ফলে অ্যাটাকার কুকির ভ্যালু সহজে বের করতে পারে না।
    
    সহজ ভাষায়, সার্ভার একটা গোপন কোড তৈরি করে কুকিতে রাখে এবং ফর্মের সাথে মিলিয়ে দেখে। যদি কোড মিলে যায়, তাহলে বোঝা যায় রিকোয়েস্টটা আসল।
    
- **সেইমসাইট কুকি অ্যাট্রিবিউট:**
    - \`SameSite=Strict\`: এই অ্যাট্রিবিউটটি কুকিকে শুধুমাত্র সেই রিকোয়েস্টের সাথেই পাঠাতে দেয়, যা একই সাইট থেকে এসেছে। এর মানে হলো, যদি কেউ অন্য কোনো ওয়েবসাইট থেকে আপনার সাইটে ঢোকার চেষ্টা করে, তাহলে এই কুকি ব্রাউজারের সাথে পাঠানো হবে না। এটা CSRF অ্যাটাক থেকে খুব ভালো প্রোটেকশন দেয়, কিন্তু কিছু ক্ষেত্রে ব্যবহারকারীর অভিজ্ঞতা খারাপ হতে পারে, কারণ অন্য সাইটের লিংকে ক্লিক করলে কুকি না থাকার কারণে কিছু ফিচার কাজ নাও করতে পারে।
    - \`SameSite=Lax\`: এই অ্যাট্রিবিউটটি \`Strict\` এর চেয়ে কিছুটা কম কঠোর। এটা কুকিকে সেইম-সাইট রিকোয়েস্টের সাথে তো পাঠায়ই, পাশাপাশি টপ-লেভেল নেভিগেশন (যেমন: লিংকে ক্লিক করে অন্য সাইট থেকে আসা) রিকোয়েস্টের সাথেও পাঠায়। এটা মূলত নিরাপত্তা এবং ব্যবহারযোগ্যতার মধ্যে একটা ভারসাম্য রক্ষা করে। CSRF অ্যাটাকের বিরুদ্ধে এটা কিছু প্রোটেকশন দেয়, কিন্তু \`Strict\` এর মতো পুরোপুরি নয়।
    - \`SameSite=None; Secure\`: এই অ্যাট্রিবিউটটি কুকিকে সব রিকোয়েস্টের সাথে পাঠাতে দেয়, তবে এর জন্য HTTPS কানেকশন থাকা বাধ্যতামূলক। \`Secure\` অ্যাট্রিবিউট নিশ্চিত করে যে কুকি শুধুমাত্র এনক্রিপ্টেড কানেকশনের মাধ্যমেই পাঠানো হবে, যা কুকি চুরি হওয়া থেকে রক্ষা করে। \`SameSite=None\` ব্যবহার করলে CSRF অ্যাটাকের ঝুঁকি থাকে, তাই এর সাথে CSRF টোকেনের মতো অন্য নিরাপত্তা ব্যবস্থা ব্যবহার করা উচিত। এটি ব্যবহার না করাই ভালো।
- **রেফারার হেডার ভ্যালিডেশন:**
    - \`Referer\` হেডার চেক করে নিশ্চিত করা যে রিকোয়েস্ট সেইম ডোমেইন থেকে এসেছে।
    - এটা আনরিলায়েবল হতে পারে, কারণ \`Referer\` হেডার সহজেই স্পুফ করা যায় বা ক্লায়েন্ট এটাকে বাদ দিতে পারে।
- **ইউজার ইন্টার‍্যাকশন (হাই-ভ্যালু ট্রানজেকশন):**
    - সেনসিটিভ অ্যাকশন কমপ্লিট করার আগে ইউজারদের রি-অথেনটিকেট করতে বা কনফার্ম করতে বলা (যেমন পাসওয়ার্ড বা OTP এন্টার করা)।

### এছাড়াও

- **API এন্ডপয়েন্ট:** CSRF টোকেন বা অন্য কোনো অথেনটিকেশন মেকানিজম (যেমন API কি, OAuth) দিয়ে API এন্ডপয়েন্টগুলো প্রোটেক্ট করুন।
- **AJAX রিকোয়েস্ট:** AJAX রিকোয়েস্টের জন্য রিকোয়েস্ট হেডারে CSRF টোকেন ইনক্লুড করুন।
- **ফ্রেমওয়ার্ক-স্পেসিফিক প্রোটেকশন:** বেশিরভাগ ওয়েব ফ্রেমওয়ার্ক (যেমন Django, Ruby on Rails, Laravel) বিল্ট-ইন CSRF প্রোটেকশন দিয়ে থাকে। এই ফিচারগুলো ব্যবহার করুন।
- **নিয়মিত সিকিউরিটি অডিট:** পটেনশিয়াল CSRF ভালনারেবিলিটি আইডেন্টিফাই ও অ্যাড্রেস করার জন্য নিয়মিত সিকিউরিটি অডিট ও পেনেট্রেশন টেস্টিং কন্ডাক্ট করুন।
- **ইউজারদের এডুকেট করুন:** ইউজারদের সাসপিসিয়াস লিংকে ক্লিক করা বা আনট্রাস্টেড ওয়েবসাইট ভিজিট করা থেকে সাবধান থাকতে ট্রেন করুন।
- **ডিফেন্স ইন ডেপথ:** CSRF অ্যাটাকের রিস্ক কমানোর জন্য মাল্টিপল লেয়ারের ডিফেন্স ব্যবহার করুন। শুধুমাত্র একটা প্রোটেকশন মেকানিজমের উপর নির্ভর করবেন না।

কিভাবে CSRF অ্যাটাক কাজ করে সেটা জেনে এবং প্রোপার প্রিভেন্টিভ মেজার ইমপ্লিমেন্ট করার মাধ্যমে, আপনি আপনার ইউজারদের অ্যাকাউন্ট হাইজ্যাক হওয়ার রিস্ক কমাতে পারেন।
`,
  },
];
